Python中的並發編程-1
現如今，我們使用的計算機早已是多 CPU 或多核的計算機，而我們使用的操作系統基本都支持“多任務”，這使得我們可以同時運行多個程序，也可以將一個程序分解為若干個相對獨立的子任務，讓多個子任務“並行”或“並發”的執行，從而縮短程序的執行時間，同時也讓用戶獲得更好的體驗。因此當下，不管用什麼編程語言進行開發，實現“並行”或“並發”編程已經成為了程序員的標配技能。為了講述如何在 Python 程序中實現“並行”或“並發”，我們需要先了解兩個重要的概念：進程和線程。

線程和進程
我們通過操作系統運行一個程序會創建出一個或多個進程，進程是具有一定獨立功能的程序關於某個數據集合上的一次運行活動。簡單的說，進程是操作系統分配存儲空間的基本單位，每個進程都有自己的地址空間、數據棧以及其他用於跟踪進程執行的輔助數據；操作系統管理所有進程的執行，為它們合理的分配資源。一個進程可以通過 fork 或 spawn 的方式創建新的進程來執行其他的任務，不過新的進程也有自己獨立的內存空間，因此兩個進程如果要共享數據，必須通過進程間通信機制來實現，具體的方式包括管道、信號、套接字等。

一個進程還可以擁有多個執行線索，簡單的說就是擁有多個可以獲得 CPU 調度的執行單元，這就是所謂的線程。由於線程在同一個進程下，它們可以共享相同的上下文，因此相對於進程而言，線程間的信息共享和通信更加容易。當然在單核 CPU 系統中，多個線程不可能同時執行，因為在某個時刻只有一個線程能夠獲得 CPU，多個線程通過共享 CPU 執行時間的方式來達到並發的效果。

在程序中使用多線程技術通常都會帶來不言而喻的好處，最主要的體現在提升程序的性能和改善用戶體驗，今天我們使用的軟件幾乎都用到了多線程技術，這一點可以利用系統自帶的進程監控工具（如 macOS 中的“活動監視器”、Windows 中的“任務管理器”）來證實，如下圖所示。

這裡，我們還需要跟大家再次強調兩個概念：並發（concurrency）和並行（parallel）。並發通常是指同一時刻只能有一條指令執行，但是多個線程對應的指令被快速輪換地執行。比如一個處理器，它先執行線程 A 的指令一段時間，再執行線程 B 的指令一段時間，再切回到線程 A 執行一段時間。由於處理器執行指令的速度和切換的速度極快，人們完全感知不到計算機在這個過程中有多個線程切換上下文執行的操作，這就使得宏觀上看起來多個線程在同時運行，但微觀上其實只有一個線程在執行。並行是指同一時刻，有多條指令在多個處理器上同時執行，並行必須要依賴於多個處理器，不論是從宏觀上還是微觀上，多個線程可以在同一時刻一起執行的。很多時候，我們並不用嚴格區分並發和並行兩個詞，所以我們有時候也把 Python 中的多線程、多進程以及異步 I/O 都視為實現並發編程的手段，但實際上前面兩者也可以實現並行編程，當然這裡還有一個全局解釋器鎖（GIL）的問題，我們稍後討論。

多線程編程
Python 標準庫中threading模塊的Thread類可以幫助我們非常輕鬆的實現多線程編程。我們用一個聯網下載文件的例子來對比使用多線程和不使用多線程到底有什麼區別，代碼如下所示。

不使用多線程的下載。
    import random
    import time


    def download(*, filename):
        start = time.time()
        print(f'開始下載 {filename}.')
        time.sleep(random.randint(3, 6))
        print(f'{filename} 下載完成.')
        end = time.time()
        print(f'下載耗時: {end - start:.3f}秒.')


    def main():
        start = time.time()
        download(filename='Python從入門到住院.pdf')
        download(filename='MySQL從刪庫到跑路.avi')
        download(filename='Linux從精通到放棄.mp4')
        end = time.time()
        print(f'總耗時: {end - start:.3f}秒.')


    if __name__ == '__main__':
        main()
#說明：上面的代碼並沒有真正實現聯網下載的功能，而是通過time.sleep()休眠一段時間來模擬下載文件需要一些時間上的開銷，跟實際下載的狀況比較類似。

運行上面的代碼，可以得到如下所示的運行結果。可以看出，當我們的程序只有一個工作線程時，每個下載任務都需要等待上一個下載任務執行結束才能開始，所以程序執行的總耗時是三個下載任務各自執行時間的總和。
    開始下載Python從入門到住院.pdf.
    Python從入門到住院.pdf下載完成.
    下載耗時: 3.005秒.
    開始下載MySQL從刪庫到跑路.avi.
    MySQL從刪庫到跑路.avi下載完成.
    下載耗時: 5.006秒.
    開始下載Linux從精通到放棄.mp4.
    Linux從精通到放棄.mp3下載完成.
    下載耗時: 6.007秒.
    總耗時: 14.018秒.

事實上，上面的三個下載任務之間並沒有邏輯上的因果關係，三者是可以“並發”的，下一個下載任務沒有必要等待上一個下載任務結束，為此，我們可以使用多線程編程來改寫上面的代碼。
    import random
    import time
    from threading import Thread


    def download(*, filename):
        start = time.time()
        print(f'開始下載 {filename}.')
        time.sleep(random.randint(3, 6))
        print(f'{filename} 下載完成.')
        end = time.time()
        print(f'下載耗時: {end - start:.3f}秒.')


    def main():
        threads = [
            Thread(target=download, kwargs={'filename': 'Python從入門到住院.pdf'}),
            Thread(target=download, kwargs={'filename': 'MySQL從刪庫到跑路.avi'}),
            Thread(target=download, kwargs={'filename': 'Linux從精通到放棄.mp4'})
        ]
        start = time.time()
        # 啟動三個線程
        for thread in threads:
            thread.start()
        # 等待線程結束
        for thread in threads:
            thread.join()
        end = time.time()
        print(f'總耗時: {end - start:.3f}秒.')


    if __name__ == '__main__':
        main()

某次的運行結果如下所示。
    開始下載 Python從入門到住院.pdf.
    開始下載 MySQL從刪庫到跑路.avi.
    開始下載 Linux從精通到放棄.mp4.
    MySQL從刪庫到跑路.avi 下載完成.
    下載耗時: 3.005秒.
    Python從入門到住院.pdf 下載完成.
    下載耗時: 5.006秒.
    Linux從精通到放棄.mp4 下載完成.
    下載耗時: 6.003秒.
    總耗時: 6.004秒.
通過上面的運行結果可以發現，整個程序的執行時間幾乎等於耗時最長的一個下載任務的執行時間，這也就意味著，三個下載任務是並發執行的，不存在一個等待另一個的情況，這樣做很顯然提高了程序的執行效率。簡單的說，如果程序中有非常耗時的執行單元，而這些耗時的執行單元之間又沒有邏輯上的因果關係，即 B 單元的執行不依賴於 A 單元的執行結果，那麼 A 和 B 兩個單元就可以放到兩個不同的線程中，讓他們並發的執行。這樣做的好處除了減少程序執行的等待時間，還可以帶來更好的用戶體驗，因為一個單元的阻塞不會造成程序的“假死”，因為程序中還有其他的單元是可以運轉的。