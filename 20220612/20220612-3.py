#對象的複制（深複製/深拷貝/深度克隆和淺複製/淺拷貝/影子克隆）

#垃圾回收、循環引用和弱引用

#Python使用了自動化內存管理，這種管理機制以引用計數為基礎，同時也引入了標記-清除和分代收集兩種機制為輔的策略。
'''
typedef struct _object {
    /* 引用计数 */
    int ob_refcnt;
    /* 对象指针 */
    struct _typeobject *ob_type;
} PyObject;

/* 增加引用計數的宏定義 */
#define Py_INCREF(op)   ((op)->ob_refcnt++)
/* 減少引用計數的宏定義 */
#define Py_DECREF(op) \ //減少計數
    if (--(op)->ob_refcnt != 0) \
        ; \
    else \
        __Py_Dealloc((PyObject *)(op))
導致引用計數+1的情況：

對像被創建，例如a = 23
對像被引用，例如b = a
對像被作為參數，傳入到一個函數中，例如f(a)
對像作為一個元素，存儲在容器中，例如list1 = [a, a]
導致引用計數-1的情況：

對象的別名被顯式銷毀，例如del a
對象的別名被賦予新的對象，例如a = 24
一個對象離開它的作用域，例如f函數執行完畢時，f函數中的局部變量（全局變量不會）
對象所在的容器被銷毀，或從容器中刪除對象
引用計數可能會導致循環引用問題，而循環引用會導致內存洩露，如下面的代碼所示。為了解決這個問題，Python中引入了“標記-清除”和“分代收集”。在創建一個對象的時候，對像被放在第一代中，如果在第一代的垃圾檢查中對象存活了下來，該對象就會被放到第二代中，同理在第二代的垃圾檢查中對象存活下來，該對象就會被放到第三代中。

# 循環引用會導致內存洩露 - Python除了引用技術還引入了標記清理和分代回收
# 在Python 3.6以前如果重寫__del__魔術方法會導致循環引用處理失效
# 如果不想造成循環引用可以使用弱引用
list1 = []
list2 = [] 
list1.append(list2)
list2.append(list1)
以下情況會導致垃圾回收：

調用gc.collect()
gc模塊的計數器達到閥值
程序退出
如果循環引用中兩個對像都定義了__del__方法，gc模塊不會銷毀這些不可達對象，因為gc模塊不知道應該先調用哪個對象的__del__方法，這個問題在Python 3.6中得到了解決。

也可以通過weakref模塊構造弱引用的方式來解決循環引用的問題。

魔法屬性和方法（請參考《Python魔法方法指南》）

有幾個小問題請大家思考：

自定義的對象能不能使用運算符做運算？
自定義的對象能不能放到set中？能去重嗎？
自定義的對象能不能作為dict的鍵？
自定義的對象能不能使用上下文語法？
'''

